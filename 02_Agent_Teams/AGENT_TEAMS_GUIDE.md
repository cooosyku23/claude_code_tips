# Claude Code Agent Teams 利用ガイド

本ガイドは、Claude Code の Agent Teams（研究プレビュー機能）について、公式ドキュメントおよび実動作の検証結果に基づいてまとめたものです。

> 検証ステータスの凡例: ✅ 実動作確認済み ｜ 📖 公式ドキュメント記載の例 ｜ ⚠️ 未検証（論理的に動作すると推定）

## Agent Teams とは

Agent Teams は、複数の Claude Code インスタンスをチームとして協調動作させる機能です。1つのセッションがチームリーダーとなり、複数のチームメイトを生成して、共有タスクリストとエージェント間メッセージングにより作業を調整します。

現在は実験的機能（Research Preview）であり、デフォルトでは無効です。環境変数 `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS` を `1` に設定するか、`settings.json` に追加することで有効化できます。

```json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

## Agent Teams でできること

### 1. 多角的なコードレビュー 📖

単一のレビュアーは一度に一種類の問題に集中しがちです。レビュー基準を独立した領域に分割することで、セキュリティ、パフォーマンス、テストカバレッジがすべて同時に徹底的にレビューされます。

```
Create an agent team to review PR #142. Spawn three reviewers:
- One focused on security implications
- One checking performance impact
- One validating test coverage
Have them each review and report findings.
```

各レビュアーが同じ PR に対して異なるフィルターを適用し、独立して作業できます。リーダーが完了後、全員の発見を統合します。

### 2. 敵対的なバグ調査 📖

根本原因が不明な場合、単一のエージェントは1つのもっともらしい説明を見つけて停止する傾向があります。チームメンバーを明示的に敵対的にすることでこれと戦います。各チームメンバーの仕事は、独自の理論を調査するだけでなく、他の理論に異議を唱えることです。

```
Users report the app exits after one message instead of staying connected.
Spawn 5 agent teammates to investigate different hypotheses.
Have them talk to each other to try to disprove each other's theories,
like a scientific debate.
Update the findings doc with whatever consensus emerges.
```

サブエージェントでは各ワーカーが独立して仮説を調査するだけですが、Agent Teams ではチームメイト同士が互いの仮説に反論できます。単一エージェントの「最初にもっともらしい答えを見つけて満足してしまう」バイアスを構造的に打破できます。

### 3. 新機能の設計探索 📖

```
I'm designing a CLI tool that helps developers track TODO comments
across their codebase. Create an agent team to explore this from
different angles: one teammate on UX, one on technical architecture,
one playing devil's advocate.
```

3つの役割が独立しており、互いを待たずに問題を探索できます。UX、技術アーキテクチャ、反対意見という異なる視点からの同時探索が価値を生みます。

### 4. カスタムサブエージェントをチームメイトとして生成 ✅

`.claude/agents/` に配置されたカスタムサブエージェントの定義を、そのままチームメイトとして生成できます。汎用エージェントが委任するのではなく、サブエージェントの専門化された定義がチームメイトに適用されます。ただし、定義のすべてが反映されるわけではありません。

#### 検証結果: 定義項目の反映状況

| 定義項目 | チームメイトへの反映 | 詳細 |
|---|---|---|
| **allowed_tools** | ✅ 基本制約として適用 | 定義の tools 制限がベースとして適用され、チーム機能（SendMessage 等）が自動追加される |
| **system_prompt** | ✅ 適用される | 専門化されたプロンプトがチームメイトに反映される |
| **model** | ❌ 無視される | 定義で sonnet や haiku を指定しても、リーダーと同じモデル（Opus 4.6）で動作する |
| **Task ツール** | ❌ 付与されない | チームメイトはさらにサブエージェントを委任（Task tool）できない |

つまり、サブエージェントの**専門性（プロンプトとツール制限）**はチームメイトに引き継がれるが、**モデル選択とサブエージェント委任は引き継がれない**。

特筆すべきは allowed_tools の挙動で、定義の tools が基本制約として適用された上で、Agent Teams のチーム機能（SendMessage 等の相互通信ツール）が追加される設計になっています。

#### プロンプト例

事前に `.claude/agents/` にサブエージェント定義ファイルが存在する前提です。プロンプト例は公式ドキュメントに倣い英語で記載していますが、日本語でも同様に動作します。

**例 1: 既存のサブエージェントを指定してチームメイトを生成**

```
Please spawn the specialized subagents as teammates:
- performance-profiler for analyzing performance
- security-auditor for auditing security
Have them work in parallel and share findings with each other.
```

このプロンプトにより、`performance-profiler` と `security-auditor` のサブエージェント定義がそのままチームメイトとして起動し、汎用エージェントではなく専門化された型として動作します。

**例 2: 多角的コードレビューにカスタムサブエージェントを活用**

```
Create an agent team to review the authentication module.
Spawn the following subagents as teammates:
- security-reviewer: audit for vulnerabilities
- code-reviewer: check code quality and maintainability
- test-validator: verify test coverage
Have them challenge each other's findings before reporting.
```

**例 3: カスタムサブエージェントと汎用チームメイトの混成チーム**

```
Create an agent team for the payment refactor:
- Spawn the api-developer subagent as a teammate for the REST endpoints
- Spawn a general-purpose teammate for database migration
- Spawn the security-reviewer subagent as a teammate for final audit
Coordinate through the shared task list.
```

#### ポイント

- プロンプト内でサブエージェント名を明示的に指定することで、その定義が適用される
- 汎用チームメイトとカスタムサブエージェントを混在させることも可能
- ✅ ツール制限とシステムプロンプトはチームメイトに引き継がれる
- ❌ モデル指定は無視される（リーダーと同じモデルで動作する）
- ❌ チームメイトはさらにサブエージェントを委任（Task tool）できない

> **注**: 上記の検証結果は実テストに基づいています（2026年2月時点）。公式ドキュメントにはカスタムサブエージェントをチームメイトとして生成する方法についての明示的な記載はありません。Research Preview のため、今後の更新で挙動が変わる可能性があります。

### 補足: Writer/Reviewer パターン

公式のベストプラクティスでは、Agent Teams の副次的なメリットとしてフレッシュなコンテキストの活用が紹介されています。フレッシュなコンテキストはコードレビューを改善します。Claude は自分が書いたコードに対してバイアスを持たないためです。テストでも同様に、一方の Claude がテストを書き、別の Claude がそのテストを通すコードを書くという使い方ができます。

## チームメイトのコンテキストと設定

### 自動的に読み込まれるプロジェクトコンテキスト

公式ドキュメントには、チームメイトが生成されるとプロジェクトコンテキストを自動的に読み込むことが明記されています。

- **CLAUDE.md**: チームメイトは作業ディレクトリの CLAUDE.md ファイルを読み込みます。プロジェクト固有のガイダンスをすべてのチームメイトに提供するために活用できます。
- **MCP サーバー**: リーダーと同じ MCP 接続が利用可能です。データベースや外部サービスへの接続がチームメイトからも使えます。
- **スキル**: `.claude/skills/` に定義されたスキルもチームメイトに読み込まれます。既存のスキル定義を活かしたチーム構成が可能です。

**注意点**: チームメイトはリーダーの会話履歴を引き継ぎません。タスク固有の詳細（ファイルパス、制約条件、完了条件など）はスポーン時のプロンプトに含める必要があります。

### 既存のスキル・サブエージェントとの共存

Agent Teams は、既存のサブエージェント・スキル構成を置き換えるものではなく、その上位で並列分配のオーケストレーション層として機能します。カスタムサブエージェントをチームメイトとして直接生成できるため、既存の定義資産をそのまま活かせます。

実動作では、チームメイト間のクロスシェアリング（互いの知見を受け取って第2パスでレポートを更新する動作）が確認されています。例えば sec-auditor が perf の定量データ（2.6x memory amplification, 52M allocations）を SECURITY.md に反映し、perf-profiler が sec のクロスリファレンスを PERF.md に追記するといった協調が自律的に行われました。

```
┌──────────────────────────────────────────────────┐
│           リーダー（オーケストレーション）           │
│           共有タスクリスト管理                      │
└─────┬──────────────┬──────────────┬──────────────┘
      │              │              │
      ▼              ▼              ▼
┌───────────┐  ┌───────────┐  ┌───────────┐
│ perf-     │  │ sec-      │  │ 汎用      │
│ profiler  │◄►│ auditor   │◄►│ reviewer  │
│           │  │           │  │           │
│ tools: ✅ │  │ tools: ✅ │  │ tools: 全 │
│ model: ❌ │  │ model: ❌ │  │           │
│ Task:  ❌ │  │ Task:  ❌ │  │ Task:  ❌ │
└───────────┘  └───────────┘  └───────────┘
   ◄──── SendMessage（自動付与）────►
```

- ✅ = サブエージェント定義から適用
- ❌ = 反映されない / 付与されない

## はじめ方

公式ドキュメントでは、以下の段階的なアプローチが推奨されています。

1. **読み取り専用タスクから始める**: 最初の Agent Teams 実行はコードレビューにする。並列リファクタリングの前に協調パターンを学ぶ
2. **デバッグタスクに進む**: 競合する仮説が並列調査の恩恵を受けるケース
3. **実装タスクに挑戦する**: チームメイトが別々のファイルを担当し、メッセージングで調整するケース

## トラブルシューティング

### ファイル競合

**症状**: 2人以上のチームメイトが同じファイルを編集すると、後から書き込んだ側が先の変更をサイレントに上書きする。マージは行われない。エラーや警告も表示されないため、変更が消失したことに気づきにくい。

**対処法**:
- チーム構成時に、各チームメイトの担当ファイルセットが重複しないように明示的に指示する（例: 「perf-profiler は PERF.md のみ編集」「sec-auditor は SECURITY.md のみ編集」）
- 変更消失が発生した場合は `git diff` や `git log` で上書きされたコミットを特定し、`git checkout` で復元する
- 共通ファイル（README.md 等）への書き込みはリーダーに集約するか、最後に1人のチームメイトがまとめて行うよう指示する

### チームメイトの強制停止

**症状**: チームメイトが想定外のファイルを変更し始めた、または長時間応答がない。

**対処法**:
- tmux/iTerm2 の分割ペインモードで動作している場合、該当ペインで `Ctrl+C` を送信してチームメイトを中断する
- in-process モード（デフォルト）の場合、リーダーセッションで `Ctrl+C` を送信するとチーム全体が停止する
- 個別のチームメイトだけを止めたい場合は、リーダーに「stop the perf-profiler teammate」と指示する
- 緊急時は `Ctrl+C` を2回連打してセッション全体を強制終了する

### 想定外の動作が発生した場合

**対処法**:
- `~/.claude/logs/` 配下にセッションログが記録される。チームメイトごとのログを確認して、どの時点で想定外の動作が始まったかを特定する
- `git status` と `git diff` で変更されたファイルの一覧と差分を確認し、意図しない変更を revert する
- CLAUDE.md にガードレールを追加する（例: 「src/ ディレクトリ以外のファイルを変更しないこと」）。チームメイトは CLAUDE.md を読み込むため、次回以降の実行で制約が適用される

### コストが予想を超えた場合

**症状**: チームメイトの通信量が多く、トークン消費が急増している。

**対処法**:
- `Ctrl+C` でセッションを中断する。中断時点までのチームメイトの作業結果はファイルシステムに残る
- 次回以降はチームメイト数を減らす（2〜3人から始める）
- チームメイト間の通信を制限する指示を入れる（例: 「各自の担当を完了してからのみ他のチームメイトにメッセージを送ること」）
- リーダーのプロンプトで作業範囲を限定する（例: 「レビュー対象は src/auth/ のみ」）

### リーダーのタイムアウト

**症状**: リーダーがチームメイトの完了を待たずにセッションが終了する。

**対処法**:
- Research Preview の既知の制限。セッション再開で作業を継続できる場合があるが、保証はされない
- 長時間のタスクは複数の短いタスクに分割し、各タスクで明示的な成果物（ファイル出力）を指示する。これにより、中断しても途中成果が残る
- 各チームメイトに「作業完了時に DONE.md に完了ステータスを書き込むこと」と指示しておくと、中断後にどこまで完了したかを確認できる

## サブエージェントとの使い分け

Agent Teams とサブエージェントはどちらもワークの並列化を可能にしますが、動作方法が根本的に異なります。

### 比較表

| 観点 | サブエージェント | Agent Teams |
|---|---|---|
| 定義方法 | Markdown + YAML ファイル（`.claude/agents/`） | 自然言語でリーダーに指示（カスタムサブエージェント定義の指定も可能。ただし model は反映されない） |
| エージェント間通信 | 不可（親に報告するのみ） | 可能（SendMessage による双方向メッセージング） |
| プロセスモデル | 親セッションのプロセス内で独立コンテキストを持つ | 完全に独立した別プロセス・別コンテキストウィンドウ |
| 再現性 | 定義ファイルで構造化・バージョン管理可能 | チーム構成自体は自然言語依存。カスタムサブエージェント定義の指定でツール制限・プロンプトの再現性は確保できるが、モデル指定は反映されない |
| コスト | 親セッションのトークンを消費 | チームメイト数に比例してトークンが増加 |
| 適したタスク | 焦点を絞った単発タスク、逐次ワークフロー | 並列探索、多角的レビュー、敵対的調査 |

### 選択の判断基準

**公式ドキュメントの方針**: ワーカー同士が互いに通信する必要があるかどうかで選ぶ。

- **サブエージェントを使うべきとき**: 素早く焦点を絞ったワーカーが必要で、結果を報告するだけでよい場合
- **Agent Teams を使うべきとき**: チームメイトが発見を共有し、互いに異議を唱え、独立して調整する必要がある場合
- **移行のタイミング**: 並列サブエージェントを実行しているがコンテキストの制限に達している場合、またはサブエージェント同士が互いに通信する必要がある場合

### Agent Teams が不向きなケース

- 順次タスク（前のステップの出力が次の入力になる）。RED→GREEN→REFACTOR のような TDD サイクルは、各フェーズが前のフェーズの成果物に依存する直列パイプラインであり、サブエージェントの逐次チェーンが適している
- 同一ファイルの編集（サイレントに上書きが発生する。詳細はトラブルシューティングを参照）
- 多くの依存関係を持つ作業
- 定義ファイルによる再現性・バージョン管理が必要なワークフロー

個々のワークフロー（TDD サイクルなど）はサブエージェントベースのまま維持し、Agent Teams は複数の独立したワークストリームの並列実行と相互通信にのみ活用するのが現実的です。

### Agent Teams の実力が最大限発揮される条件

公式ドキュメントに基づき、以下の条件を満たすタスクで Agent Teams の価値が最大化します。

1. **各チームメイトが独立して並行作業できる**: 互いの完了を待つ必要がない
2. **チームメイト間の意見の対立や多角的視点に価値がある**: 単一視点では見落としが生じるタスク
3. **同時探索であり、順次依存ではない**: パイプライン型ではなくファンアウト型の構造

加えて、Agent Teams は単一セッションよりもはるかに多くのトークンを使用します。研究、レビュー、新機能開発では追加トークンに見合う価値がありますが、ルーティンタスクには単一セッションのほうがコスト効率が良いことを念頭に置いてください。

## 既知の制限事項

- **実験的機能**: セッション再開、タスク調整、シャットダウン動作に既知の制限がある
- **宣言的なチーム定義ファイルがない**: チーム構成自体は毎回自然言語で指示する必要がある。カスタムサブエージェント定義のツール制限・システムプロンプトはチームメイトに適用されるが、モデル指定は反映されない
- **チームメイトの階層的委任不可**: チームメイトとして起動したエージェントには Task ツールが付与されないため、さらにサブエージェントを呼ぶことはできない
- **トークンコスト**: 「チームメイト数 × 各チームメイトのタスク量」に加え、リーダーのオーケストレーションとエージェント間メッセージングのオーバーヘッドが発生する。実測値はタスクの複雑さと通信量に大きく依存するため、小規模なチーム（2〜3人）から始めてコスト感を掴むことを推奨
- **ファイル競合**: 2人のチームメイトが同じファイルを編集するとサイレントに上書きが発生する。詳細と対処法はトラブルシューティングを参照
- **表示モード**: 分割ペインには tmux または iTerm2 が必要。VS Code の統合ターミナルや Windows Terminal ではサポートされていない（デフォルトの in-process モードはどこでも動作する）

## 参考リンク

- [Agent Teams 公式ドキュメント](https://code.claude.com/docs/en/agent-teams)
- [サブエージェント公式ドキュメント](https://code.claude.com/docs/en/sub-agents)
- [Claude Code 拡張機能の概要](https://code.claude.com/docs/en/features-overview)
- [ベストプラクティス](https://code.claude.com/docs/en/best-practices)
